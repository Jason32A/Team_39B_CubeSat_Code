#pragma config(Sensor, in1,    RightArmPot,    sensorPotentiometer)
#pragma config(Sensor, in2,    LeftArmPot,     sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ClawRightLimit, sensorTouch)
#pragma config(Sensor, dgtl2,  ClawLeftLimit,  sensorTouch)
#pragma config(Motor,  port1,           ClawLeft,      tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LeftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightBack,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           LeftY,         tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           LeftArm,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           RightArm,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           RightY,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           LeftFront,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int joyThresh = 10; // This variable controls the size of the deadzone for the joysticks
float kP = 0.5;
float kI = 0.0;
float kD = 0.0;
float maxIntegral = 40;
int armPower = 0;


float target = 0.0; //DO NOT TOUCH DIRECTLY ON PAIN OF BREAKING ARMS

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(115)

#include "Vex_Competition_Includes.c"


/**
*
* DriveControl moves the drive based upon the inputs from the parameters
* @param leftPower int -128 to 127
* @param rightPower int -128 to 127
*
*/

int mapJoyInt (TVexJoysticks input)
{
    if (abs(vexRT[input]) > joyThresh)
    {
        return vexRT[input];
    }
    return 0;
}

void driveControl (int leftPower, int rightPower)
{
	motor[LeftBack] = leftPower;
	motor[LeftFront] = leftPower;
	motor[RightBack] = rightPower;
	motor[RightFront] = rightPower;
}

void armControl (int power)
{
	motor[RightArm] = power;
	motor[LeftArm] = power;
	motor[RightY] = power;
	motor[LeftY] = power;
}

void clawControl (int power)
{
	//if sensor is on and we still try to move inwards, this will stop the arm.
	//negative values of power mean they are going outward.
	motor[ClawLeft] = power * (power < 0 || !SensorValue[ClawLeftLimit]);
	motor[ClawRight] = power * (power < 0 || !SensorValue[ClawRightLimit]);
}

void resetMotors()
{
    motor[LeftBack] = 0;
    motor[LeftFront] = 0;
    motor[RightBack] = 0;
    motor[RightFront] = 0;
    motor[RightArm] = 0;
    motor[LeftArm] = 0;
    motor[RightY] = 0;
    motor[LeftY] = 0;
    motor[ClawRight] = 0;
    motor[ClawLeft] = 0;
}

void ArmPIDControl (int input)
{
		target += input;
}

task ArmPID()
{
		float integral = 0;
		float prevDiff = 0;
		while(1)
		{
				float error = target - SensorValue[RightArmPot];

				integral += error;

				if(integral > maxIntegral)
				{
						integral = maxIntegral;
				}

				armPower = kP*error + kI * integral + kD * prevDiff;
				prevDiff = error;
		}
}

void stateArmControl (int input)
{
		if(input > 0)
		{
				input = 0;
		}
		int defcase = input%3;
		if(defcase == 0)
		{
				target = 2050;
		}
		else if(defcase == 1)
		{
				target = 2100;
		}
		else if(defcase == 2)
		{
				target = 4000;
		}
}

/**
*
* mapJoyInt takes the TVexJoysticks input value and a threshold value and returns an integer
* @param TVexJoysticks is a created variable that accepts joystick channels
* @param threshold is an int -128 to 127
*
*/

int mapButtonInt5()
{
		if(vexRT[Btn5D])
		{
        return -128;
    }
    else if(vexRT[Btn5U])
    {
        return 127;
    }
    else
    {
    		return 0;
  	}
}

int mapButtonInt6()
{
		if(vexRT[Btn6D])
		{
    		return -128;
    }
    else if(vexRT[Btn6U])
    {
        return 127;
    }
    else
    {
    		return 0;
  	}
}

//Divider for readability

void pre_auton()
{

}

//Divider for readability

task autonomous()
{

}

//Divider for readability

task usercontrol()
{
    while (true)
		{
			driveControl(mapJoyInt(Ch3),mapJoyInt(Ch2));
			armControl(mapButtonInt6());
			clawControl(mapButtonInt5());
			writeDebugStreamLine("Arm Potentiometer: %d",SensorValue[RightArmPot]);
			wait1Msec(20);
		}
}
