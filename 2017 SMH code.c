#pragma config(Sensor, in1,    ArmPot,         sensorPotentiometer)
#pragma config(Sensor, in2,    AutonSelect,    sensorPotentiometer)
#pragma config(Sensor, dgtl1,  ClawRightLimit, sensorTouch)
#pragma config(Sensor, dgtl2,  ClawLeftLimit,  sensorTouch)
#pragma config(Motor,  port1,           ClawLeft,      tmotorVex393HighSpeed_HBridge, openLoop, reversed)
#pragma config(Motor,  port2,           LeftBack,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           RightBack,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           LeftY,         tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           LeftArm,       tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           RightArm,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           RightY,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           LeftFront,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           RightFront,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          ClawRight,     tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define joyThresh 10 // This variable controls the size of the deadzone for the joysticks
#define kP 0.1
#define kI 0.0
#define kD 0.0
#define maxIntegral 40
#define maxForward 127,127
#define maxBackward -127,-127
#define maxRight 127,-127
#define maxLeft -127,127
#define baseStop 0,0
#define singleTileTime 1000
#define spin90Time 300
#define setClawPowerTo claw.currentPower[0] =

#define setClawTimeTo claw.targetTime =
#define setDriveBaseTimeTo driveBase.targetTime =


int armState = 0;

typedef struct
{
		int targetTime;
		int currentPower[2];
}Subsystem;

Subsystem driveBase;
Subsystem claw;

#define potStartPoint 460
#define potEndPoint 2800

float target = 0.0; //DO NOT TOUCH DIRECTLY ON PAIN OF BREAKING ARMS

#pragma competitionControl(Competition)
#pragma autonomousDuration(15)
#pragma userControlDuration(115)

#include "Vex_Competition_Includes.c"


/**
*
* DriveControl moves the drive based upon the inputs from the parameters
* @param leftPower int -128 to 127
* @param rightPower int -128 to 127
*
*/

int mapJoyInt (TVexJoysticks input)
{
    if (abs(vexRT[input]) > joyThresh)
    {
        return vexRT[input];
    }
    return 0;
}

void driveControl (int leftPower = 0, int rightPower = 0)
{
	motor[LeftBack] = leftPower;
	motor[LeftFront] = leftPower;
	motor[RightBack] = rightPower;
	motor[RightFront] = rightPower;
}

void armControl (int power = 0)
{
	motor[RightArm] = power;
	motor[LeftArm] = power;
	motor[RightY] = power;
	motor[LeftY] = power;
}

void resetTimers()
{
		clearTimer(T1);
		clearTimer(T2);
		clearTimer(T3);
		clearTimer(T4);
}

void clawControl (int power = 0)
{
	//if sensor is on and we still try to move inwards, this will stop the arm.
	//negative values of power mean they are going outward.
	motor[ClawLeft] = power * (power < 0 || !SensorValue[ClawLeftLimit]);
	motor[ClawRight] = power * (power < 0 || !SensorValue[ClawRightLimit]);
}

void resetMotors()
{
    motor[LeftBack] = 0;
    motor[LeftFront] = 0;
    motor[RightBack] = 0;
    motor[RightFront] = 0;
    motor[RightArm] = 0;
    motor[LeftArm] = 0;
    motor[RightY] = 0;
    motor[LeftY] = 0;
    motor[ClawRight] = 0;
    motor[ClawLeft] = 0;
}

void ArmPIDControl (int input)
{
		target = input;
}


void stateArmControl ()
{
		if(armState == 0)
		{
				target = potStartPoint;
		}
		else if(armState == 1)
		{
				target = potStartPoint + 400;
		}
		else if(armState == 2)
		{
				target = potEndPoint;
		}
}


task ArmPID()
{
		writeDebugStreamLine("ArmPID started");
		float integral = 0;
		float prevDiff = 0;
		int armPower = 0;
		while(1)
		{

				float error = target - SensorValue[ArmPot];

				integral += error;

				if(integral > maxIntegral)
				{
						integral = maxIntegral;
				}

				armPower = kP*error*(armPower > 0 ? 2 : 0.5 ) + kI * integral + kD * prevDiff;
				if(abs(armPower) > 20)
				{
						if(abs(armPower)> 127)
						{
								armPower = 127 * (armPower > 0 ? 1 : -1);
						}
						armControl(armPower);
				}
				prevDiff = error;
				wait1Msec(20);
				stateArmControl();
		}
}

task button6Switch()
{
		while(true)
		{
				while(vexRT[Btn6U]);
				armState++;
				armState %= 3;
				wait1Msec(100);
				while(!vexRT[Btn6U]);
		}
}

task timerControl
{

		while(true)
		{
				if(time1[T1] < driveBase.targetTime)
				{
						driveControl(driveBase.currentPower[0], driveBase.currentPower[1]);
				}
				else if(time1[T1] > driveBase.targetTime)
				{
						driveControl();
						clearTimer(T1);
						driveBase.targetTime = 0;
				}
				if(time1[T2] < claw.targetTime)
				{
						clawControl(claw.currentPower[0]);
				}
				else if(time1[T2] > claw.targetTime)
				{
						clawControl();
						clearTimer(T2);
						claw.targetTime = 0;
				}
		}
}

/**
*
* mapJoyInt takes the TVexJoysticks input value and a threshold value and returns an integer
* @param TVexJoysticks is a created variable that accepts joystick channels
* @param threshold is an int -128 to 127
*
*/

int mapButtonInt5()
{
		if(vexRT[Btn5D])
		{
        return -1;
    }
    else if(vexRT[Btn5U])
    {
        return 1;
    }
    else
    {
    		return 0;
  	}
}

int mapButtonInt6()
{
		if(vexRT[Btn6D])
		{
    		return -1;
    }
    else if(vexRT[Btn6U])
    {
        return 1;
    }
    else
    {
    		return 0;
  	}
}

void deploy()
{
		startTask(ArmPID);
		armState = 0;
		driveControl(maxBackward);
		wait1Msec(500);
}

void cubeAuton (bool side)
{
		deploy();
		writeDebugStreamLine("cubeAuton started , side is %d", side);
		driveControl(maxForward);
		clawControl(-127);
		wait1Msec(singleTileTime);
		clawControl(0);
		wait1Msec(singleTileTime*0.5);
		clawControl(127);
		wait1Msec(500);
		armState = 1;
		wait1Msec(500);
		if(side)
		{
				driveControl(maxRight);
		}
		else
		{
				driveControl(maxLeft);
		}//
		wait1Msec((int)(spin90Time*3));
		driveControl(baseStop);
		wait1Msec(500);
		driveControl(maxBackward);
		wait1Msec(singleTileTime*2);
		driveControl(baseStop);
		armState = 2;
		wait1Msec(500);
		clawControl(-127);
		wait1Msec(500);
		clawControl(0);
		armState = 0;
}

void backRowAuton (bool side)
{
		deploy();
		writeDebugStreamLine("BackRowAuton started , side is %d", side);
		driveControl(maxForward);
		clawControl(-127);
		wait1Msec(singleTileTime);
		clawControl(0);
		wait1Msec(singleTileTime*1.2);
		driveControl(baseStop);
		clawControl(127);
		wait1Msec(500);
		armState = 1;
		driveControl(maxBackward);
		wait1Msec(singleTileTime*1.3);
		driveControl(0);
		if (side)
		{
				driveControl(maxRight);
		}
		else
		{
			driveControl(maxLeft);
		}//
		wait1Msec(spin90Time);
		driveControl(maxBackward);
		wait1Msec(singleTileTime);
		if (side)
		{
				driveControl(maxRight);
		}
		else
		{
			driveControl(maxLeft);
		}
		wait1Msec(spin90Time);
		driveControl(maxBackward);
		wait1Msec(singleTileTime);
		driveControl(baseStop);
		armState = 2;
		wait1Msec(1000);
		clawControl(-127);
		wait1Msec(700);
		clawControl(0);
		armState = 0;;
		if(side)
		{
				driveControl(maxRight);

		}
		else
		{
				driveControl(maxLeft);//
		}
		wait1Msec(200);
		driveControl(baseStop);
		wait1Msec(1400);
		armControl(0);
		driveControl(maxForward);
		wait1Msec(singleTileTime);
		clawControl(127);
		driveControl(baseStop);
		wait1Msec(700);
		armState = 1;
		driveControl(maxBackward);
		wait1Msec(singleTileTime);
		driveControl(baseStop);
		armState = 2;
		wait1Msec(1000);
		clawControl(-127);
		wait1Msec(1000);
		clawControl(0);
		armState = 0;
}

//Divider for readability

void pre_auton()
{

}


//Divider for readability

task autonomous()
{
		int auton = SensorValue[AutonSelect]/1024;
		if (auton == 0)
		{
				cubeAuton(true); // turns right, is suitable for red left side or blue left
		}
		else if (auton == 1)
		{
				cubeAuton(false); // turns left, is suitable for red right or blue right
		}
		else if (auton == 2)
		{
				backRowAuton(false); // is suitable for blue left, or red left
		}
		else if (auton == 3)
		{
				backRowAuton(true); // is suitable for blue right, or red right
		}
}

//Divider for readability

task usercontrol()
{
		startTask(ArmPID);
		startTask(button6Switch);
    while (true)
		{
			driveControl(mapJoyInt(Ch3),mapJoyInt(Ch2));
			//armControl(mapButtonInt6()*127);
			clawControl(mapButtonInt5()*127);

		}
}
